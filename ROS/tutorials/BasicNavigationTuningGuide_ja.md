# ナビゲーション基本チューニングガイド

http://wiki.ros.org/ja/navigation/Tutorials/Navigation%20Tuning%20Guide

## 説明

このガイドは、ロボットのROSナビゲーションスタックをチューニングする方法について、いくつかの標準的なアドバイスを提供することを目的としています。このガイドは決して包括的なものではありませんが、プロセスに対するいくつかの洞察を与えるはずです。また、この投稿の前にROSナビゲーションチュートリアルを読んでおくことをお勧めします。このチュートリアルでは、ロボットにナビゲーションスタックをセットアップする際の良い概要を説明していますが、このガイドではそのプロセスについてアドバイスします。

チュートリアルのレベル 中級 

## ロボットのナビゲーションの準備はできていますか？

新しいロボットのナビゲーションスタックをチューニングする際に遭遇する問題の大部分は、ローカルプランナのパラメータをチューニングする以外の部分にあります。ロボットのオドメトリ、ローカライゼーション、センサー、その他ナビゲーションを効果的に行うための前提条件に問題があることが多いのです。ですから、私が最初に行うのは、ロボット自体がナビゲーションの準備が整っているかどうかを確認することです。これは、レンジセンサー、オドメトリー、ローカライズの3つの要素からなるチェックです。

### レンジセンサー

ロボットがレーザーなどの距離センサーから情報を得られないと、ナビゲーションは何も機能しません。rvizでセンサー情報を見ることができるか、それが比較的正しく見えるか、そして期待される速度で入ってくるかどうかを確認します。

### オドメトリ

ロボットを正しく位置決めするのに苦労することがよくあります。ロボットが常に迷子になり、AMCLのパラメータをいじっているうちに、本当の原因はロボットのオドメトリーにあることがわかります。そこで、私はロボットのオドメトリを信じるために、常に2つのサニティチェックを行います。

まず、オドメトリの回転がどの程度妥当なのかをチェックします。rvizを起動し、フレームを「odm」に設定し、ロボットが提供するレーザースキャンを表示し、そのトピックの減衰時間を高く設定（20秒程度）し、インプレースローテーションを実行します。そして、その後の回転でスキャンがどれだけ一致するかを調べます。理想はスキャンがぴったり重なることですが、多少の回転ずれは想定内なので、1〜2度以上のずれがないことを確認するだけです。

次のテストは、翻訳用のオドメトリのサニティチェックです。ロボットを壁から数メートル離して、同じようにrvizをセットアップします。理想的なのは、壁が1つのスキャンに見えることですが、数センチ以上の厚みがないことを確認するだけです。もし、壁に向かって1メートル走ったときに、半メートルに渡ってスキャンが広がっていたら、オドメトリに何か問題がある可能性があります。

### ローカライゼーション

オドメトリとレーザースキャナの両方が適切に動作していれば、マップの作成とAMCLのチューニングは通常、それほど悪くありません。まず、gmappingかkartoを起動して、ジョイスティックでロボットを動かして地図を作成します。そして、そのマップをAMCLで使って、ロボットがローカライズされていることを確認します。ロボットのオドメトリがあまり良くない場合は、AMCLのオドメトリモデルパラメータを少しいじります。システム全体のテストとしては、レーザースキャンとマップがrvizの「マップ」フレームで視覚化され、レーザースキャンが周囲のマップとうまくマッチしていることを確認することです。また、Rvizでロボットのinitialposeを正確に設定した上で、動作することを確認します。

## コストマップ

ロボットがナビゲーションの前提条件を満たしていることに満足したら、私はコストマップが適切に設定されていることを確認したいと思います。コストマップの設定方法の詳細は ROS Navigation Tutorial と costmap_2d のドキュメントに譲りますが、私がよく行うことについてヒントをあげます。コストマップのチューニングで便利だと思うことをいくつか。

* 各観測源に対して、センサーが実際にパブリッシュする速度に基づいて、expected_update_rate パラメータを設定することを確認します。しかし、センサーが期待される速度よりずっと下に落ちたときに、ナビゲーションから警告を受けるのは良いことです。

* transform_toleranceパラメータをシステムに合わせて適切に設定します。tf を使って "base_link" フレームから "map" フレームへのトランスフォームの予想レイテンシーをチェックするのは良いことです。私は通常、tf_monitorを使用してシステムの遅延を確認し、そこから控えめにパラメータを設定します。また、tf_monitorが報告する遅延が十分に大きい場合は、遅延の原因となっているものを確認するために、少し突き合わせることもあります。そうすると、あるロボットのトランスフォームのパブリッシュ方法に問題があることがわかることがあります。

* 処理能力の低いロボットでは、map_update_rateのパラメータを下げることを検討します。ただし、この場合、センサーデータがコストマップに反映されるのが遅くなり、ロボットが障害物に反応する速度が遅くなることを考慮します。

* publish_frequencyパラメータは、rvizでコストマップを可視化するのに便利ですが、特に大きなグローバルマップの場合、このパラメータによって動作が遅くなることがあります。本番システムでは、コストマップの公開頻度を下げることを検討し、非常に大きなマップを視覚化する必要があるときは、本当に低い頻度に設定するようにします。

* コストマップに voxel_grid モデルとコストマップモデルのどちらを使うかは、ロボットが持つセンサー群に大きく依存します。3Dベースのコストマップのチューニングは、未知の空間についての考慮が必要になるため、より複雑です。もし、私が使っているロボットが平面レーザーしか持っていない場合は、常にコストマップモデルをマップに使用します。

* 時には、オドメトリックフレームだけでナビゲーションを行うことができると便利です。そのためには、local_costmap_params.yamlファイルをglobal_costmap_params.yamlファイルにコピーして、マップの幅と高さを10m程度に変更するのが一番簡単だと思います。ローカライズのパフォーマンスとは別にナビゲーションを調整したい場合、これは本当に簡単な方法です。

* 私は、ロボットの大きさや処理能力に応じて、使用する地図の解像度を選ぶことが多いです。PR2のように処理能力が高く、狭い場所を移動するようなロボットには、0.025mのような細かいマップを使用します。ルンバなどでは、計算負荷を軽減するために0.1mまで解像度を上げることもあります。

* Rvizは、コストマップが正しく動作しているかどうかを確認するのに最適な方法です。私は通常、コストマップから障害物データを表示し、ジョイスティック制御でロボットを運転しながら、マップとレーザースキャンの両方と一致していることを確認します。これは、センサーのデータがコストマップに正しく反映されているかどうかを確認するためです。未知の空間をロボットで追跡することにした場合、大抵はコストマップにvoxel_gridモデルを使用するロボットですが、未知の空間が合理的に除去されているかどうかを確認するために、未知の空間の視覚化を確認することにしています。コストマップから障害物が正しく除去されているかどうかを確認する方法としては、ロボットの前を歩いてみて、ロボットが私を見て除去しているかどうかを確認するのがよいでしょう。コストマップからrvizに発行されるトピックの詳細については、rvizのチュートリアルを参照してください。

* ナビゲーションスタックがコストマップだけを実行しているときに、システム負荷をチェックするのは良いアイデアです。つまり、move_baseノードを立ち上げて、ゴールを送らず、負荷を見るのです。この時点でコンピュータがダウンしている場合、プランナーを実行する可能性があるなら、CPUを節約するためのパラメータを調整する必要があることがわかります。

## ローカルプランナー

コストマップがうまく動作していることに満足したら、ローカルプランナーのパラメータを調整することにします。適度な加速度制限を持つロボットでは、私は通常dwa_local_plannerを使用します。加速度制限が低く、各ステップで加速度制限を考慮したロールアウトが有効なロボットでは、base_local_plannerを使用します . dwa_local_plannerのチューニングは、そのパラメータがdynamically_reconfigure可能なので、base_local_plannerのチューニングよりも快適ですが、ナビゲーションスタックのために全面的にdynamic_reconfigureを加えることはロードマップにあります。さて、プランナーのためのヒントについてです。

* 両方のプランナーにとって最も重要なことは、与えられたロボットに対して加速度限界のパラメータが正しく設定されていることです。このパラメータがずれていると、ロボットの動作が最適でなくなると思います。もし、ロボットの加速度制限がわからない場合は、時間をかけて、ある期間、モーターに最大並進速度と最大回転速度を指令するスクリプトを書き、オドメトリから報告された速度を見て、そこから加速度制限を導きます（オドメトリが合理的に推定してくれると仮定して）。これらのパラメータを合理的に設定することで、後で多くの時間を節約することができます。

* 加速度制限が低いロボットの場合は、dwaをfalseに設定してbase_local_plannerを実行するようにします。dwaをtrueに設定した後、利用可能な処理能力に応じてvx_samplesパラメータを8から15の間に更新するようにします。これにより、ロールアウトで非円形のカーブが生成されるようになります。

* 作業しているロボットのローカライゼーションが良くない場合は、ゴールトレランスパラメータを他の場合よりも少し高く設定するようにします。また、ロボットの最小回転速度が高い場合は、回転公差を大きくして、ゴール地点での振動を防ぎます。

* CPUの都合で解像度が低い場合は、sim_granularityのパラメータを少し上げて、サイクルを節約することもあります。

* プランナーの path_distance_bias と goal_distance_bias (base_local_planner では pdist_scale と gdist_scale) パラメータをあまり変更することはありません。私がそうするときは、通常、NavFn以外のグローバルプランナーで動作するために、ローカルプランナーが計画された経路から離れる自由を制限しようとしているときです。path_distance_biasパラメータを上げると、ロボットはより忠実に経路をたどるようになりますが、その代償として、ゴールに早く向かうようになります。この重みを高くしすぎると、ロボットは移動を拒否するようになります。

* もし、コスト関数について知的な推論をしたい場合は、meter_scoringパラメータをtrueに設定するようにします。これにより、コスト関数の距離がセル単位ではなくメートル単位になり、あるマップ解像度でコスト関数を調整しても、他の解像度に移動したときに妥当な動作が期待できるようになります。さらに、publish_cost_gridパラメータをtrueに設定することにより、ローカルプランナーが生成したコスト関数をrvizで視覚化することができるようになりました。(これはどういうわけかドキュメントに書かれていないのですが、そのうち書きます)。メートル単位のコスト関数が与えられると、ゴールに向かって1メートル移動するコストのトレードオフを計算し、計画した経路からどれだけ離れているかをバランスさせることができます。これによって、どのように調整すればよいかがわかるようになります。

* 軌道は終点からスコアリングされます。つまり、sim_timeパラメータを異なる値に設定することで、ロボットの動作に大きな影響を与えることができます。私は通常このパラメータを1-2秒の間に設定します。高く設定すると、軌道が少し滑らかになります。ただし、最小速度にsim_periodを掛けたものが、ゴールに対する許容誤差の2倍以下であることを確認してください。そうしないと、ロボットは目標に向かって移動するよりも、目標位置の範囲外の場所で回転することを好むようになります。

* また、正確な軌道シミュレーションは、オドメトリによる適切な速度推定値に依存します。これは、dwa_local_plannerとbase_local_plannerの両方が、計画サイクルの実行可能な速度空間を決定するために、ロボットの加速度限界とともに、この速度推定値を使用するという事実に由来しています。オドメトリから得られる速度推定値は完璧である必要はありませんが、最適な動作を得るためには、少なくともそれに近い値であることを確認することが重要です。

## ROSナビゲーションチューニングガイド

もしあなたのロボットがナビゲーションの準備ができていて、ロボットのナビゲーション動作を最適化するプロセスを進めようとしているなら、Kaiyu Zhengが作成したROS Navigation Tuning Guideをご覧ください。速度や加速度の設定、グローバルプランナー、ローカルプランナー（特にDWAローカルプランナー）、コストマップ、AMCL（簡単に）、回復動作などのコンポーネントについて説明されています。このガイドで紹介されたアイデアに基づいたSCITOS G5ロボットのナビゲーションシステムの改良のためのビデオデモを紹介します。このガイドは決して完全ではありませんし（例えばAMCLのセクションはもっと議論が必要）、誤りを含んでいる可能性があります。この Github Repository https://github.com/zkytony/ROSNavigationGuide に課題やプルリクエストを提出し、貢献することができます。
